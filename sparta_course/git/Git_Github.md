# Git & Github

<br>

- gitを使うメリット 
  - スピーディー
  - シンプルな設計
  - ブランチが並列で開発可能
  - 大規模プロジェクトを効率的に取り扱える

- githubとは
  - プルリクエストで複数人での開発が可能
  - 世界中のチームがGithub上で開発可能

- gitは、データをスナップショットを記録する
  - 変更があったファイルをスナップショットとして記録
  - 変更がなかったファイルは前回分を使用する

- なぜ、スナップショットで記録するのか？
  - 複数人で開発する際のスピードを上げることが出来る
    - ブランチを切れるから
  -  差分で記録していると
     - マージする際に逐一差分を計算しないといけなくなる

- gitは、前のバージョンに戻すことが出来る
  - バージョンを記録しているから
  - 最新のコミットする際に直前のコミットも記録する

- リポジトリとは、履歴データの置き場、履歴データのデータベース
- コミットとは、スナップショットを記録すること
- ローカルリポジトリとは、自分のパソコン上の履歴データの保管場所
- ワークツリーとは、自分のパソコン上の作業場
- Githubとは、ネットワーク上のコード置き場

<br>

ローカルでスナップショットを記録→Githuへアップするまでの流れ
1. ワークツリーでファイルを変更
2. ローカルリポジトリにスナップショットを保存
3. ローカルリポジトリからGithubへアップ

<br>

他人のリポジトリを変更するまでの流れ
1. Githubの記録をローカルリポジトリへ
2. ワークツリーにローカルリポジトリからGithubの記録を反映

<br>

- ローカルは３つのエリアに分かれている
  - ワークツリー
  - ステージ
  - リポジトリ

<br>

1. ワークツリーでファイルを変更
2. git add にて、ステージでコミットする変更を準備する
3. git commit にてローカルリポジトリにスナップショットを記録する

- なぜいったんステージに上げるのか
  - 沢山のファイルを変更している際に、変更が完了したファイルだけのスナップショットを記録したいから

<br>

- git add にて起こること
  - ワークツリーで作業したファイルの圧縮ファイルをリポジトリに作成
    - 圧縮ファイルになるのは、変更されたファイルのみ
  - ステージにインデックスとして、作業したファイルと圧縮ファイルを保管する

- git commit にてツリーとコミットが作成される
  - ツリーとは、インデックスの中身まるっとそのまま
  - コミットに含まれる情報
    - ツリー情報
      - コミットした際のスナップショット(ファイル構成(ファイル名+ファイル内容))がわかる
    - 親コミット
      - 直前のコミット情報（スナップショット）
    - 作成者
    - 日付
    - コミットメッセージ

<br>

ファイル変更からgit commitまででそれぞれのエリアに含まれるもの
- ワークツリーには、変更したファイル
- ステージには、インデックス
- リポジトリには、圧縮ファイルとツリーとコミット

<br>

- Gitのデータ構造のまとめ
  - リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成することでデータを保存している
  - コミットが親コミットを持つことで変更履歴を辿ることが出来る
  - Gitの本質はデータを圧縮して、スナップショットで保存していること
  - gitコマンドは、そのデータに対していろいろな操作をしている

<br>

- `Gitオブジェクト`とは、`git add`や`git commit`した時に作成される`圧縮ファイル`、`ツリーファイル`、`コミットファイル`のこと。Gitオブジェクトは、`.git/objects`ディレクトリの下に保存される

<br>

- `圧縮ファイル`とは、ファイルの中身そのものを圧縮したもの。正確には`blobオブジェクト`という。圧縮ファイルには、元のファイル名の情報は記録されない。ファイル名は`ハッシュID`になるから。
  - blobとは、カタマリという意味
  - ハッシュIDは、40文字の英数字
  - ハッシュIDは、ファイルの中身に対して一意になる

<br>

- `ツリーファイル`とは、１つのファイルに１つの圧縮ファイルが対応していて、１つのディレクトリに１つのツリーファイルが対応している。ツリーファイルは、構造や名前を持たない圧縮ファイルに構造を与えるもので、圧縮ファイルやツリーファイルを保存している
  - ディレクトリの１つの階層ごとに１つのツリーファイルになっている
  - ツリーファイルには、圧縮ファイルだけでなく、ツリーファイルも保存されている

<br>

- `コミットファイル`とは、いつ・誰が・何を・何のためにhンこうしたのかなどの情報を保存するもの。正確には、`commitオブジェクト`という

<br>

※treeコマンドのインストール方法(homebrewインストール済み)
`$ brew install tree`

<br>

- ローカルリポジトリの作成
  - `$ git init`
    - `.git/`ディレクトリが作成される
      - `.git/objects` (リポジトリ) 
        - 圧縮ファイル
        - ツリーファイル
        - コミットファイル
      - インデックスファイル
      - 設定ファイル

メモ）git add をすることで、.git/indexディレクトリが作成される

<br>

- ステージへの追加
  - git add <ファイル名>
  - git add <ディレクトリ名>
  - git add .

<br>

- `$ git commit -v`
  - 変更内容を確認したい時

<br>

- `$ git status`
  - ワークツリーとステージ間で変更されたファイル情報
    - インデックスが保持していないファイルが表示される
    - `change not staged for commit:`
  - ステージとリポジトリ間で変更されたファイル情報
    - 前回コミットしてからステージに追加されたファイルが表示される
    - `change to be committed`

<br>

- git addする前の変更分を確認
  - `$ git diff`
  - `$ git diff <ファイル名>`

- git addした後の変更分を確認
  - `$ git diff --staged`

<br>

- 変更履歴の確認
-  `$ git log`
- `$ git log --oneline`
  - 一行で表示させる
- `$ git log -p <ファイル名> `
  - ファイル名の変更差分を表示
- `$ git log -n <コミット数>`
  - 表示するコミット数を制限

<br>

- ファイルごと削除（ワークツリーとリポジトリーから）
  - `$ git rm <ファイル名>`
  - `$ git rm -r <ディレクトリ名>`

- ワークツリーにファイルを残したい時
  - `$ git rm --cached <ファイル名>`
  - 間違ってパスワードなどが乗ったファイルをコミットしてしまった時など
  - リポジトリには載せたくないが、ワークツリーには必要なファイル

- `Untracked files:`
  - つまり、リポジトリから削除されたが、ワークツリーにはファイルがあるため、ステージが混乱している

<br>

ファイルの移動を記録する

- `$ git mv <旧ファイル名> <新ファイル名>`

　上と下は同じ意味をもつ

- `$ mv <旧ファイル名> <新ファイル名>`
- `$ git rm <旧ファイル名>`
- `$ git add <新ファイル名>`

<br>

リモートリポジトリ（GitHub）を新規追加する

- `$ git remote add origin <リポジトリのURL>`
  - `origin`というショートカットでURLのリモートリポジトリを登録すると言う意味

- `$ git push <リモート名> <ブランチ名>`
- push初回時にすると良いこと
  - `$ git push -u origin master`
    - `-u`オプションをつけることで、次回以降`$ git push`だけでoriginにmasterブランチをpushできるようになる

<br>

エイリアスの設定

- `$ git config --global alias.<エイリアス> <正しいコマンド>`

- git configの内容確認
  - `$ git config --list`

<br>

- バージョン管理したくないファイルとは
  - パスワードなどの機密情報が乗ったファイル
  - チーム開発に必要ないファイル
    - macやwindowsで自動生成されるファイルやcacheなど
- `.gitignoreファイル`に指定する

```.gitignore
# #から始まる行はコメント

#　指定したファイルを除外
index.html
#ルートディレクトリを指定
/root.html
# ディレクトリ以外を除外
dir/
# /以外の文字列にマッチ「*」
/*/*.css
```

<br>

ワークツリーのファイルを元の状態に戻したい

つまり、変更されたワークツリーの状態を、git addで作成されたステージの状態と同じにする

- ファイルへの変更を取り消す
  - `$ git checkout -- <ファイル名>`
  - `$ git checkout -- <ディレクトリ名>`
  - 全変更を取り消すとき
    - `$ git checkout -- .`

<br>

ステージに追加した変更を元に戻したい。間違ったワークツリーのファイルをgit addしてしまった場合

つまり、リポジトリから最新の情報を取り出し、ステージに反映させる


- `$ git reset HEAD <ファイル名>`
- `$ git reset HEAD <ディレクトリ名>`
- `$ git reset HEAD .`
  - 全変更を取り消す方法

- `HEAD`とは、現在いるディレクトリの最新のコミットのこと

memo)　指定した変更をステージから取り消すだけなので、ワークツリーのファイルには影響を与えない

<br>

直前のコミットをやり直す

- `$ git commit --amend`
  - リモートリポジトリにPushしたコミットはやり直し厳禁！

<br>

直前のコミットをやり直す流れ

1. 間違った内容でコミットする
2. 正しい内容にワークツリーを変更
3. `git add`でステージにあげる
4. `$ git commit --amend`を行い、先程の間違ったコミットを修正できる
5. `$ git log -p -n 1`でログを確認してみる

<br>

リモートを表示する

- `$ git remote`
  - ショートカットが表示される
- `$ git remote -v`
  - URLが表示

- `fetch`とは
  - `$ git fetch <リモート名>`とすることで、ローカルからリモートリポジトリの最新の情報をみることができる
  - 必要に応じてリモートリポジトリとマージすることもできる。
  - このコマンドは他のリポジトリデータを取得するだけで、ローカルで作業しているファイルを書き換えたりマージしたりはしない
  - 取ってくると言う意味
  - リモートリポジトリからローカルリポジトリに取得する
    - 保存場所は、`remotes/リモート名/ブランチ`
  - 取得した内容をワークツリーに反映させたい場合は`merge`すべし

<br>

fetchからmaegeまでの流れ

1. `$ git fetch origin`
2. `$ git branch -a`
   1. ずべてのブランチを表示させる
   2. remotes/origin/masterがあるはず
3. `$ git checkout remotes/origin/maste`
   1. fetchしたブランチへ移動`
   2. fetchした内容がちゃんとあるか確認
4. `$ git checkout master`
5. `$ git merge origin/master`
   1. fetchしたoriginのmasterをワークツリーに反映

<br>

リモートリポジトリを新規追加する

- `$ git remote add <リモート名> <リモートURL>`
  - リモート名というショートカットでURLのリモートリポジトリを登録できる
    - originもショートカット

<br>

pullとは、fetchでの操作をまとめて行える操作

- `$ git pull <リモート名> <ブランチ名>`

<br>

fetch pull　使い分け

- fetchは、安全
- pullは、`自分がいるブランチに統合されるのでブランチの確認を怠るな！`

<br>

- `$ git remote show <リモート名>`
  - リモートの詳細を確認できるよ

<br>

- リモート名を変更する方法
  - `$ git remote rename <旧リモート名> <新リモート名>`

- リモートを削除する方法
  - `$ git remote rm <リモート名>`

<br>

- `branch`は、コミットIDを記録したポインター。コミットを指し示すポインターのようなもの
- brnchにおける`HEAD`は、作業中のbranchのこと

- branchやHEADなどの情報は、`.git/HEAD`, `.git/refs/`に保存されている
  - `ref`とは、HEADとなっているブランチのこと

<br>

- `$ git brnach <新ブランチ名>`
  - ブランチを作成するだけで、移動はしない
- `$ git branch -a`
  - リモートブラントなどの確認できる

<br>

- マージには３種類ある
  - `Fast Forward`
    - ブランチが枝分かれしてなかった時は、ブランチのポインタを前に進めるだけ
    - `git pull`がそれ
  - `Auto Mege`
    - 枝分かれして開発していた場合、マージコミットという新しいコミットを作る
    - 取り込みたいブランチに切り替えて、取り込む
  - `Conflict`
    - 複数人が、同じファイルの同じ行に対して異なる編集を行った際に発生する
    - 手作業

<br>

コンフリクトの解決方法

- `git status`でどのファイルでコンフリクトが起きたか確認

コンフリクトしたファイルについて

```
<h1>aboit Git</h1>
<p>welcome</p>
<<<<< HEAD
<p>lets learn git</p>
========
<p>learn about git commit</p>
>>>>>>> feature
```

見方

```
<<HEAD ~ == は、HEADの変更分
== ~ >> featureは、featureの変更分
```

解決方法

1. `まずは落ち着け！`
2. ファイルの内容を正しく書き換える
3. 「<<」「==」「>>」の記述を削除する

<br>

- コフリクトが発生しないようにするためには
  - 複数人で同じファイルを変更しない
  - pullやmergeする前に変更中の状態をなくしておく(commitやstash)
  - pullする時は、pullするブランチに移動してからpullする
  - 慌てない

<br>

- `$ git brnach -m <ブランチ名>`
  - 作業中のブランチの名前を変更する方法
  - `-m`とは、moveの略

<br>

- プルリクエストとは、自分の変更したコードをリポジトリに取り込んでもらえるように依頼すること
 - チームの誰かに変更したコードをレビューしてもらい、バグなどを発生させないようにするため

<br>

- プルリクエストの大まかな流れ

1. master/mainブランチを最新に更新
  1. `$ git pull origin master`
2. 作業ブランチを作成
3. ファイルを変更
4. 変更をコミット
5. Githubへプッシュ
6. プルリクエストを送る
7. コードレビュー
  1. `reviewers`でレビューしてもらう人を選択する
8. プルリクエストをリポジトリにマージ
9.  ブランチを削除

<br>

- `GitHub Flow` とは
 1. masterブランチから開発ブランチを作成
 2. ファイルを変更しコミット
 3. 同名のブランチをGitHubへプッシュ
 4. プルリクを送る
 5. コードレビューし、masterブランチにマージ
 6. masterブランチをデプロイ

<br>

- `github flow`を実践する上でのポイント
 - masterブランチは、常にデプロイできる状態に保つ
 - 新開発は、masterブランチから新しいブランチを作成してスタート
 - 作成した新しいブランチ上で作業しコミットする
 - 定期的にPushする
   - 完全に作業が終わらなくてもいい
   - 他のチームメンバーが開発状況を把握できるから
 - masterにマージするためにプルリクエストを使う
 - 必ずレビューを受けるようにする
 - Approve(承認)された後、masterブランチにマージしたらすぐにデプロイする
   - テストとデプロイ作業は自動化する必要がある

<br>

- `Rebase`とは？
 - 変更を統合する際に、履歴を綺麗に整えるためのコマンド
 - `$ g trebase <ブランチ名>`
   - ブランチの基点となるコミットを別のコミットに移動させる
   - <ブランチ名>の変更分の取り込みながら、親コミットを<ブランチ名>が指すコミットに移す
   - よって、コミットの流れを一直線にできる

<br>

- Rebaseの流れ ~masterブランチにfeatureブランチの内容を取り込みたいよ~(野田クリスタル)

1. コミット1を指すmasterとfeatureがあると仮定
2. masterブランチで作業し、コミット
3. コミット2ができる(親コミットはコミット1)
4. featureにて作業、コミット
5. コミット3ができる(親コミットはコミット1)
6. masterブランチにfeatureブランチの内容を取り込みたいよ
7. `$ git checkout feature` featureブランチへ移動
8. `$ git rebase master` featureにmasterをrebaseする
9. すると、featureブランチが指すコミットがコミット2を親に持つ、コミット3’が作成される
10. つまり、コミットが一直線になる
11. `$ git checkout master` masterブランチへ移動
12. `$ git merge feature`をすることで
13. masterとfeatureが同じコミット3’を示すことになる
14. ↑これは、`Fast Forward`が起きている
15. mergeコミットは作られていない

<br>

- rebaseとmergeの違い
 - `rebase`の場合、ブランチが指すコミットの親コミットは１つなる
 - `merge`の場合、masterが指すコミットの親コミットが複数になる
   - featureブランチは移動していないから

<br>

迷ったら見返せ！
https://www.udemy.com/course/unscared_git/learn/lecture/7091490#content

<br>

- `fast forward` をしたくない場合
 - `$ git config --global merge.ff false`
 - ブランチで作業した履歴を残しておきたい場合 

<br>

- `git rebase`してはいけない場合
 - GitHubにプッシュしたコミットをrebaseするのはNG
   - ローカルの内容とGitHubの内容に矛盾が生じるため、ローカルの内容を受け付けなくなる(Push出来なくなる)
   - `$ git push -f`も絶対ダメ！
     - gitの履歴が完全に壊れてしますため

<br>

- `merge`
 - メリット  
   - コンフリクトの解決が比較的簡単
 - デメリット  
   - マージコミットがたくさんあると履歴が複雑化する
 - 作業の履歴を残したいならmergeを使う！

<br>

- `rebase`
 - メリット
   - 履歴を綺麗にたもつことができる
 - デメリット
   - コンフリクトの解決が若干面倒になる(コミットそれぞれに解消が必要なため)
     - コンフリクトが各コミットごとに発生する
 - 履歴を綺麗にしたいならrebaseを使う！

<br>

pullにはマージ型とリベース型がある

- merge型
 - `$ git pull <リモート名> <ブランチ名>`
 - いわゆるいつものpullがそれ
 - マージコミットが残るため、マージしたという記録を残したい場合に使う

- rebase型
 - `$ git pull --rebase <リモート名> <ブランチ名>`
 - マージコミットが残らないため、Githubの内容を取得したいだけのときに使う
 - プルをリベース型に設定する方法
   - `$ git config --global pull.rebase true`
   - masterブランチでgit pull するときだけに設定したい場合
   - `$ git config brnach,master.rebase true`

<br>

rebaseで履歴を書き換える流れの例

1. touch first.html
2. git add first.html
3. git commit -m "add first" 
4. touch second.html
5. git add second.html
6. git commit -m "add second"
7. touch third.html
8. git add third.html
9. git commit -m "add third"
10. `$ git rebase -i HEAD~3`
11. コミットエディタが開く
12. 変更したいコミットを`pick`から`edit`に変える
13. 変更したいファイルを変更
14. git add <変更したファイル>
15. git commit --amend
16. コミットエディタが開き、コミットメッセージの変更ができる
17. 残りがpickだけがなれば`git rebase --continue`
18. ↑この真偽が謎

<br>

- HEAD~<数字>(チルダ) 
 - HEADを基点にして<数字>分の親コミットまでを指定する

- HEAD^<数字>(キャレット)
 - マージした場合の<数字>番目の親を指定する

<br>

- コミットを削除したり、順番を入れ替えたりする方法
  - コミットエディタ内で編集すればOK
    - 履歴は古い順に表示されるので注意。`git log`とは逆

<br>

- コミットをまとめる方法
  - `squash`を使う

```
$ git rebase -i HEAD~3
# コミットエディタ
pick jngoj ヘッダを修正
squash dhafo ファイルを追加
squash sahfa README修正
```

上記のようにすることで３つのコミットファイルを１つ（ヘッダを修正）にまとめることができる

<br>

コミットを分割する方法

```
$ git rebase -i HEAD~3

# commit editer
pick hsoa ヘッダー修正
pick lkei　ファイル追加
pick qyqy　READMEとindex修正
```
以上が現状の場合

```
# コミットを分割する
pick hsoa ヘッダー修正
pick lkei　ファイル追加
edit qyqy　READMEとindex修正

# terminal
$ git reset HEAD^
$ git add README
$ git commit -m "README修正
$ git add index.html
$ git commit -m "index.html修正"
$ git rebase --continue
$ git log --oneline -n 3
# 確認してみて
```

上記の手順で、コミットを分割することができる

<br>

- `タグ`とは、コミットを参照しやすくするためにわかりやすい名前をつけるもの。
  - リリースポイント（リリースした日付など）に使われる

- `$ git tag`
  - タグの一覧を表示
- `$ git tag -l "条件"`
  - 条件にあうタグ表示
- `$ git show <タグ名>`
  - タグの詳細を表示
<br>

- タグは２種類ある(-a の有無の違い)
  - `annotated`
    - 注釈付き
    - `$ git tag -a <タグ名> -m <"メッセージ">`
  - `lightweight`
    - 軽量
    - `$ git tag <タグ名>`
  - 後からタグをつける方法
    - `$ git tag <タグ名> <コミット名>`

<br>

- タグをリモートリポジトリに送信する方法（ただのgit pushではタグは送信されない）
  - `$ git push <リモート名> <タグ名>`
  - タグを一斉に送信する場合は
  - `$ git push origin --tag`
- github > code > release > tags

<br>

- `git stash`
  - git push するまではないけど他のブランチで作業しないと行けなくなった場合に、ワークツリーでの変更分とステージ上の変更分を一旦stashに退避させることができる

- `git stash list`
  - 退避したリスト表示

- `git stash apply`
  - 最新の作業を復元できる
- `git stash apply --index`
  - ステージの状況も復元できる
- `git stash apply <スタッシュ名>`
  - 特定の作業を復元
  - `git stash apply stash@{1}`

- `git stash drop`
  - 最新の作業を削除
- `git stash drop <スタッシュ名>`
  - 特定のスタッシュを削除
- `git stash clear`
  - 全スタッシュを削除










